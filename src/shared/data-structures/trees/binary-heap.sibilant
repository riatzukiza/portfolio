(define Heapable Spawnable
  (expects heap)
  (expects index)
  (expects compare-to)
  (gett right-index (+ (* 2 this.index) 2))
  (gett left-index (+ (* 2 this.index) 1))
  (gett parent-index (Math.floor (/ (- this.index 1) 2)))
  (gett smallest-child-index
        (if (or (>= this.right-index this.heap.length)
                (< (get this.heap this.left-index 'priority)
                   (get this.heap this.right-index 'priority)))
            this.left-index
            this.right-index))

  (gett root (first this.heap))
  (gett min-val this.root)
  (gett left (get this.heap this.left-index))
  (gett right (get this.heap this.right-index))
  (gett parent (get this.heap this.parent-index))
  )
(define Binary-heap Heapable
  (interface Heapable)
  (priority 0)

  (init ( priority (heap (or this.heap [])))
        (.insert this this))

  (def clear ()
    (set this 
         'priority null)
    (assign this.heap.length 0))
  (def get-min () this.root)
  (def-generic update-by-index ( new-priority index heap)
    (const old-priority (get heap index 'priority))
    (set heap index '*priority new-priority)
    (if (< new-priority old-priority)
        (.*sift-up this index)
        (.*sift-down this index)))
  (def-generic extract-min (min-val heap)
    (if! (not heap.length)
         (return null))
    (var last (last heap)j)
    (assign (first heap) last)
    (assign (last heap) min-val)
    (.pop heap)
    (.*sift-down this 0))
  (def-generic insert (heapable heap)
    (if! (not heapable.heap) (throw (new Type-error "Inserting non heapable value")))
    (if! (!= heapable.heap heap) (throw (new Type-error "Inserting heapable to wrong heap")))
    (assign heapable.index heap.length)
    (.push heap heapable)
    (.*sift-up this heapable.index heapable.parent-index heap)
    )

  (def-generic *sift-up (index parent-index heap)
    (while (and (!= index 0)
                (= (.compare-to (get heap index )
                                (get heap parent-index )) 1))
      (const current-node (get heap index))
      (assign current-node.index parent-index)

      (const parent-node (get heap parent-index))
      (assign parent-node current-index)

      (set heap index parent-node)
      (set heap parent-index current-node)

      (assign index parent-index)
      (assign parent-index (get heap index 'parent-index)))
    )

  (def-generic *sift-down (index left-index right-index heap)
    (while (or (and (< left-index heap.length)
                    (= (.compare-to (get heap index )
                                    (get heap left-index  ))
                       1))
               (and (< left-index heap.length)
                    (= (.compare-to (get heap index )
                                    (get heap left-index ))
                       1)))
      (const smallest-child-index (if (or (>= right-index heap.length)
                                          (= (.compare-to (get heap left-index 'priority)
                                                          (get heap right-index 'priority))
                                             -1))
                          left-index
                          right-index))
      (var smallest-node (get heap smallest-child-index))
      (var current-node (get heap index))

      (assign smallest-node.index index)
      (assign current-node.index smallest-child-index)

      (set heap index smallest-node)
      (set heap smallest-child-index current-node)

      (assign index smallest-child-index)
      (assign left-index smallest-node.left-index
              right-index smallest-node.right-index))
    )
  )
