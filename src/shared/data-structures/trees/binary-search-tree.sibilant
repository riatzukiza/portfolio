(require! (lit Spawnable) "@shared/data-structures/spawnable.js"
          (lit List) "@shared/data-structures/list.js"
          )
(macro get? (...args)
       (const terminal (.pop args))
       [...(.map args (=> (arg) [@arg "?."])) terminal])
(define Binary-search-tree  Spawnable
  (init ((key null)
         (parent null)
         (values (.spawn List))
         ))

  (gett has-two-children? (and this.left this.right))
  (gett root
        (var node this)
        (while node.parent
          (assign node node.parent))


        (return node)
        )

  (gett grandparent
        ;; (get? this parent parent)
        this.parent.parent
        )
  (gett is-leaf? (and (not this.left) (not this.right)) )
  (gett successor (var temp this)
        (while temp.left
          (assign temp temp.left))
        (return temp)
        )
  (gett is-root? (= this this.root))
  (gett uncle (if (or (not this.parent) (not this.parent.parent))
                  null

                  this.parent.is-on-left?
                  this.parent.parent.right

                  this.parent.parent.left))
  (gett is-on-left? (= this this.parent.left))
  (gett sibling (if (not this.parent)
                    null
                    this.is-on-left?
                    this.parent.right

                    this.parent.left))
  (def move-down (n-parent)
    (if this.parent
        (if this.is-on-left?
            (assign this.parent.left n-parent)
            (assign this.parent.right n-parent)))
    (assign n-parent.parent this.parent)
    (assign this.parent n-parent))

  (def swap-keys (node)
    (const temp this.key)
    (assign this.key node.key)
    (assign node.key temp))

  (def-generic rotate-left ()
    (const n-parent this.right)

    (.move-down this n-parent)

    (assign this.right n-parent.left)

    (if n-parent.left (assign n-parent.left.parent this))

    (assign n-parent.left this))

  (def-generic rotate-right ()
    (const n-parent this.left)

    (.move-down this n-parent)

    (assign this.left n-parent.right)

    (if n-parent.right
        (assign n-parent.right.parent this))
    (assign n-parent.right this))

  (def-generic set (key value )
    (if (or (not this.key) (= key this.key) )
        (do (set this 'key key )
            (.push this.values value))
        (< key this.key)
        (if this.left
            (.set this.left key value)
            (assign this.left
                    (.set
                     (.spawn Binary-search-tree
                             null
                            this) key value))

            )

        (> key this.key)
        (if this.right
            (.set this.right key value)
            (assign this.right (.set (.spawn Binary-search-tree
                                             null
                                             this)
                                     key value))))
    this)

  (def map (f)
    (const r (.spawn this.proto))
    (each this (node k)
          (.set r k (f node k) ))
    (return  r))

  (def each (f)
    (.each this.values (=> (v) (f v this.key)))
    (if this.left (.each this.left f))
    (if this.right (.each this.right f)))

  (def remove (key value)
    (doc-string "shared.datastructures.trees.binary-search-tree.remove"
                "key: A numeric key, value: A value to be removed."
                "Search the tree as deep as needed to find and remove a value")
    (const branch (.search this key ))
    (if (.remove branch.values value)
        (if (= branch.values.length 0)
            (assign this.key null))))

  (def prune (key)
    (doc-string "shared.datastructures.trees.binary-search-tree.prune"
                "key: A numeric key"
                "Search the tree for a key, removing the branch"))
  (def-generic search (key )
    (doc-string "shared.datastructures.trees.binary-searchtree.search"
                "key: A numeric key."
                "Search the tree for a key, returning the branch."
                )
    (if (= key this.key)
        this
        (and (< key this.key) this.left)
        (.search this.left key )
        (and (> key this.key) this.right)
        (.search this.right key )
        this)))

(export Binary-search-tree)
