
(include "kit-interface/header")
(import-namespace interface)

(require! (lit Spawnable) "@shared/data-structures/spawnable.js"
          (lit Entity-group) "@shared/ecs.js"
          (lit Position) "@shared/systems/position.js"
          (lit Physics) "@shared/systems/physics.js"
          )

(define Unit-instance Spawnable
  (init (entity group))
  (gett game this.group.game)
  (gett pos this.entity.position-interface)
  (gett physics this.entity.physical-properties)
  (gett scale this.physics.scale)
  (gett mass this.physics.mass)
  (def register ())
  (def clear ()
    (assign this.unit null
            this.group null)))
(export Unit-instance)

(define Unit-group Interface
  (doc-string "Shared.Units.Unit-group"
              "

Name: Name of the unit group
types: A list of lists of components
Game: A game instance.
groups (optional): A list of entity groups associated with units in this group.
Allows for easy cross entity interactions.
Components: A list of components
"
              "
A physical thing in the world which interacts with other units.

There can be several types of units in a game, the most basic we will be considering for now are dynamic and static.

The only difference is one can move and the other cannot.

Possibilities for other distinctions later are:
Destructable
Neutral

"
              "
We've chosen to implement this layer of abstraction as an encapsulation of entity groups rather than an extension as we use the entity group and language around it on previous projects, and we don't want to break other projects just to implement this right here and now.

This may change as these are to be used instead of entity groups for the most part instead of along side. Though we may decide differntly.
"
              )
  (base-components [Position Physics])
  (interface Unit-instance)
  (template true)

  (init (group-name
         types
         game
         (components (.flat [types this.base-components]))
         (group ((create Entity-group)
                 (+ name "Unit")
                 components
                 game.ent))
         ))
  (def build ()
    (if (not this.template)
        (.init this)
        )
    )
  (def spawn (...args)
    (const entity (.spawn this.group))
    (const unit (.spawn this.interface entity this))
    (assign entity.unit unit)
    (for-of! c entity.components
             (assign c.unit unit))
    (.register unit ...args)
    (return unit))

  (def despawn (unit)
    (for-of! c unit.entity.components
             (assign c.unit null))
    (.despawn this.group unit.entity)
    (.despawn unit)))

(export Unit-group)
