(include "kit/header")
(import-namespace kit)


(include "kit-interface/header")
(import-namespace interface)

(def-lit-macro def-curried (name args ...body) `(property @name (R.curry (lambda @args ...@body))))

(require! (lit Component System) "./ecs"
          (lit Physics) "sibilant-game-engine/client/systems/physics"
          (lit Position) "sibilant-game-engine/client/systems/position"
          (lit Velocity) "sibilant-game-engine/client/systems/velocity"
          (lit Vector) "@shared/vectors.js"
          (lit Tree-map) "tree-kit"
          Quad-tree  "@timohausmann/quadtree-js"

          )

(require! (lit List) "sibilant-game-engine/client/data-structures/list"
          (lit Dynamic-pool) "sibilant-game-engine/client/pooling/dynamic-pool")

()

(def-generic List.rotate-until (predicate (t 0))
             (if (predicate this.head.item)
                 this.head.item
                 (> t (- this.size 1))
                 (pipe this .rotate (.rotate-until predicate (++ t)))
                 false))

(define Collision-bounds Component
  (area 0)

  (gett dimensions this.area)
  (gett dim this.dimensions)

  (gett scale (* 1.2  this.physics.scale))
  (gett physics (.get this.system.process.systems Physics this.entity))


  (gett min-bounds

        (var (lit x y) this.pos))
  (gett bounding-box
        )

  (gett max-bounds

        (var height   this.scale
             width this.scale)

        (var (lit x y) this.pos)

        (lit (x  (+ x this.scale))
             (y (+ y this.scale))))

  (gett position (.get this.system.process.systems Position this.entity ))
  (gett pos this.position)
  (gett velocity (.get this.system.process.systems Velocity this.entity)))

(export Collision-bounds)

(define Collision System
  (interface Collision-bounds)

  (def-generic set-bounds ((height 100) (width 100)
                           (max-objects 10)
                           (max-levels 10))
    (if! this.quads (throw (new Error "bounds are already set")))

    (assign this.quads (new Quad-tree
                            (lit (x 0)
                                 (y 0)
                                 width,height)
                            max-objects
                            max-levels)))
  (def-curried *check  (c c*)

      ;; shape of bounding box for non rotated rectangles.

      (var d [(- c*.min-bounds.x c.max-bounds.x)
              (- c*.min-bounds.y c.max-bounds.y)
              (- c.min-bounds.x c*.max-bounds.x)
              (- c.min-bounds.y c*.max-bounds.y)])

      (var [d1x d1y d2x d2y] d)

      (set c 'colliding false)
      (if! (not (or (>= d1x 0) (>= d1y 0) (>= d2x 0) (>= d2y 0)))
        (set c 'colliding true)
        (set c* 'colliding true)
        (.emit c.system.game.events "collision"
               c c* d))
      (return)
      )

  ;; (def *update-component (c)
  ;;   (unless (or (= c.type 'static)
  ;;               c.colliding)
  ;;     (.each c.system.components
  ;;            (.*check this c))
  ;;     (set c 'checked true)))
  (def-generic *update-all (t components)
    (.clear this.quads)
    (assign this.bit-field ((create Tree-map)))

    (each  components (c)
             (const pos [ (Math.round c.pos.x)
                          (Math.round c.pos.y)])
             (if! (this.bit-field.has pos)
                  (return (c.system.game.events.emit 'collision c this.bit-field.get(pos))))
             (const bounds (lit (x (get pos 0))
                                (y (get pos 1))
                                (height c.scale)
                                (width c.scale)))
             (.set this.bit-field pos c)
             (.insert this.quads bounds))
    (each components (c) 
             (const possible-collisions (.retrieve this.quads
                                                   (lit (x c.pos.x)
                                                    (y c.pos.y)
                                                    (height c.scale)
                                                    (width c.scale))))
             (for-of! pc possible-collisions
                      (const c* (.get this.bit-field [pc.x pc.y]))
                      (if! (not (= c c*))
                           (.*check this c c*)))
             (return))
    (return null)


    )
  )
(export Collision)
