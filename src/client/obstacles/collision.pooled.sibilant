
(include "kit/header")
(import-namespace kit)


(include "kit-interface/header")
(import-namespace interface)

(def-lit-macro def-curried (name args ...body) `(property @name (R.curry (lambda @args ...@body))))

(require! (lit Component System) "./ecs"
          (lit Physics) "sibilant-game-engine/client/systems/physics"
          (lit Position) "sibilant-game-engine/client/systems/position"
          (lit Velocity) "sibilant-game-engine/client/systems/velocity"
          (lit Vector) "@shared/vectors.js"
          (lit Tree-map) "tree-kit"
          Quad-tree  "@timohausmann/quadtree-js"

          )

(require! (lit List) "sibilant-game-engine/client/data-structures/list"
          (lit Dynamic-pool) "sibilant-game-engine/client/pooling/dynamic-pool")


(def-generic List.rotate-until (predicate (t 0))
             (if (predicate this.head.item)
                 this.head.item
                 (> t (- this.size 1))
                 (pipe this .rotate (.rotate-until predicate (++ t)))
                 false))
(define Boundry Interface (init (x y hieght width))
        (def clear ()
          (set this 'x 0 'y 0 'height 0 'width 0)))
;; (def-generic Tree-map.clear () (each this (e) ))

(const boundry-pool ((create Dynamic-pool) Boundry))
(const bit-field-pool ((create Dynamic-pool) Tree-map))

(define Collision-bounds Component
  (area 0)

  (gett dimensions this.area)
  (gett dim this.dimensions)

  (gett scale (* 1  this.physics.scale))
  (gett physics (.get this.system.process.systems Physics this.entity))


  (gett min-bounds this.pos)
  (gett bounding-box)

  (gett max-bounds (.spawn Vector (+ this.pos.x this.scale) (+ this.pos.y this.scale)))
  (gett position (.get this.system.process.systems Position this.entity ))
  (gett pos this.position)
  (gett velocity (.get this.system.process.systems Velocity this.entity)))

(export Collision-bounds)

(define Collision System
  (interface Collision-bounds)

  (def-generic set-bounds ((height 100) (width 100)
                           (max-objects 10)
                           (max-levels 10))
    (if! this.quads (throw (new Error "bounds are already set")))

    (assign this.quads (new Quad-tree
                            (lit (x 0)
                                 (y 0)
                                 width,height)
                            max-objects
                            max-levels)))
  (def-curried *check  (c c*)

    ;; shape of bounding box for non rotated rectangles.
    (const max-bounds c.max-bounds )
    (const max-bounds* c*.max-bounds )
    (const dx1 (- c*.min-bounds.x max-bounds.x))
    (const dx2 (- c.min-bounds.x max-bounds*.x))

    (set c 'colliding false)
    (if! (not (or (>=  dx1 0) (>= dx1 0) (>= dx2 0) (>= dx2 0)))
         (set c 'colliding true)
         (set c* 'colliding true)
         (.emit c.system.game.events "collision"
                c c*))
    (.despawn max-bounds)
    (.despawn max-bounds*)
    (return))

  (def-generic *update-all (t components)
    (.clear this.quads)
    (assign this.bit-field ((create Tree-map)))

    (each  components (c)
           (const pos  [(Math.round c.pos.x) (Math.round c.pos.y)])
             (if! (this.bit-field.has pos)
                  (return (c.system.game.events.emit 'collision c  (this.bit-field.get pos))))
             (const bounds (lit (x (get pos 0))
                                (y (get pos 1))
                                (height c.scale)
                                (width c.scale)))
             (.set this.bit-field pos c)
             (.insert this.quads bounds))
    (each components (c)
          (const bounds (.spawn boundry-pool  c.pos.x c.pos.y c.scale c.scale))
          (const possible-collisions (.retrieve this.quads bounds))
          (.despawn boundry-pool bounds)

          (for-of! pc possible-collisions
                   (const c* (.get this.bit-field [pc.x pc.y]))
                   (if! (not (= c c*))
                        (.*check this c c*)))
          (return))
    (assign this.bit-field null)
    (return null)


    )
  )
(export Collision)
